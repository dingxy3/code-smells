####                                                 Bloaters(吸血者)

```
    bloaters是一种代码、方法、类已经发展到了一个巨大的规模，以至很难工作。
    通常这种情况不会立马产生，是经过时间的积累项目的发展，尤其是开发者没有努力的想要去改变根除它。
```

**1、Long Method **

症状：

```
一个方法包含了太多行数的代码，通常某个方法已经超过了10行并且开始促使你问为什么呢
```

问题原因：

```
   就像加州旅馆一样，一些东西总是被添加进去但是却没有任何东西被删除掉。
   因为写代码总是比读代码容易。这种方法习惯和气味一直没有被注意到，直到它变成了一个丑陋的超大的野兽。
   心理上，通常新建一个新方法的难度超过了在先有方法上去添加改变，你会这样思想斗争着： 
   “它仅仅只需要在老方法改动的地方添加2行代码就可以实现功能，为了这2行代码创建一个新的方法是得不偿失的”     这就意味着另一行代码被添加进去，然后又是另一行代码，以此类推就产生了一团混乱的意大利面条代码。
```

治疗：

```
根据经验来说，如果你感觉到在一个方法内部需要增加一些注释，你就应该拿走这些代码把它放到一个新的方法里。
如果它需要解释的话，甚至一个单独的行应该被分割成一个新的单独的方法。
如果这个方法有一个清晰的名字，没有人为了知道这个方法干了什么会去查看这个代码内部的具体实现。
```

* 减少一个方法体的长度，使用 提取方法  Extract Method

  **Problem:**

  ```java
  /**
    *你有一个可以组织在一起的代码片段
    */
  void printOwing() {
    printBanner();
  
    //print details
    System.out.println("name: " + name);
    System.out.println("amount: " + getOutstanding());
  }
  ```

  **Solution:**

  ```java
  /**
   *移动这些代码到一个单独的新的方法，使用方法调用替换这些老的代码
   */ 
  void printOwing() {
    printBanner();
    printDetails(getOutstanding());
  }
  
  void printDetails(double outstanding) {
    System.out.println("name: " + name);
    System.out.println("amount: " + outstanding);
  }
  ```

  ##### 为什么重构

  ```
   在一个方法里发现的行越多，就越难理解清楚这个方法是干什么的，这就是重构的最主要原因。
   除了消除你的代码粗边界外，提取方法也是是许多重构手段，去处理的第一步
  ```

  ##### 好处

  ```
      更加可读的代码！保证看到这个方法的名字就知道你这个方法的目的，形如：creatOrder()等。
      越少的代码重复；通常在一个方法里发现一些代码能被用在你程序里其他地方，
      因此你可以替换掉重复的代码片段，在这个位置去调用你准备抽象出来新的方法。
      隔离出独立的代码部分，意味着出现错误的可能性更小，例如错误的变量被修改了。
  ```

  ##### 怎么样重构

  ```
     1、 知其名而晓其意:
      新建一个新的方法并且给它取一个这样的名字,看到这个方法名字，这个方法的目的就不言而喻呢。 
     2、复制相关的代码片段到你的新方法里，删除旧的地方的代码片段，取而代之用新的方法调用替换。
     找到代码片段里的所有被使用的变量，它们仅仅声明在代码片段里，没有在外部被使用，简单点做法是移到新方法里，它们会变成这
  个新方法的内部变量。
     3、如果这个变量声明在你要提取的方法之前。你需要把这个变量作为参数传递给你的新方法，为了使用先前就包含在里面的值。通过使用
   Replace Temp with Query，有时候很轻松的就可以摆脱这些变量。
  ```

  ##### 2、Replace Temp with Query

  **problem**

      ```
  将表达式的结果放在本地变量中以便稍后再代码中使用
      ```

  ```java
  double calculateTotal() {
    double basePrice = quantity * itemPrice;
    if (basePrice > 1000) {
      return basePrice * 0.95;
    }
    else {
      return basePrice * 0.98;
    }
  }
  ```

  **Solution**

  ```
  移动整个表达式到一个单独的方法里，这个方法返回表达式的结果
  用查询方法的方式去替代这个变量，如果需要合并这个新的方法在
  其他方法里。
  ```

  ```java
  double calculateTotal() {
    if (basePrice() > 1000) {
      return basePrice() * 0.95;
    }
    else {
      return basePrice() * 0.98;
    }
  }
  double basePrice() {
    return quantity * itemPrice;
  }
  ```

  **为什么要重构**

  ```
  这种重构可以为上面的Extract Method打下基础。
  同样的表达式有时候也会被发现在其它方法中使用，这也是考虑新建
  一个通用的方法的原因。
  ```

  