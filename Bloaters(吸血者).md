####                                                 Bloaters(吸血者)

```
    bloaters是一种代码、方法、类已经发展到了一个巨大的规模，以至很难工作。
    通常这种情况不会立马产生，是经过时间的积累项目的发展，尤其是开发者没有努力的想要去改变根除它。
```

* ##### Long Method

* ##### Large Class

* ##### Primitive Obsession

* ##### Long Parameter List

* ##### Data Clumps

  

**1、Long Method**

症状：

```
一个方法包含了太多行数的代码，通常某个方法已经超过了10行并且开始促使你问为什么呢
```

问题原因：

```
   就像加州旅馆一样，一些东西总是被添加进去但是却没有任何东西被删除掉。
   因为写代码总是比读代码容易。这种方法习惯和气味一直没有被注意到，直到它变成了一个丑陋的超大的野兽。
   心理上，通常新建一个新方法的难度超过了在先有方法上去添加改变，你会这样思想斗争着： 
   “它仅仅只需要在老方法改动的地方添加2行代码就可以实现功能，为了这2行代码创建一个新的方法是得不偿失的”     这就意味着另一行代码被添加进去，然后又是另一行代码，以此类推就产生了一团混乱的意大利面条代码。
```

治疗：

```
根据经验来说，如果你感觉到在一个方法内部需要增加一些注释，你就应该拿走这些代码把它放到一个新的方法里。
如果它需要解释的话，甚至一个单独的行应该被分割成一个新的单独的方法。
如果这个方法有一个清晰的名字，没有人为了知道这个方法干了什么会去查看这个代码内部的具体实现。
```

* 减少一个方法体的长度，使用 提取方法  Extract Method

  **Problem:**

  ```java
  /**
    *你有一个可以组织在一起的代码片段
    */
  void printOwing() {
    printBanner();
  
    //print details
    System.out.println("name: " + name);
    System.out.println("amount: " + getOutstanding());
  }
  ```

  **Solution:**

  ```java
  /**
   *移动这些代码到一个单独的新的方法，使用方法调用替换这些老的代码
   */ 
  void printOwing() {
    printBanner();
    printDetails(getOutstanding());
  }
  
  void printDetails(double outstanding) {
    System.out.println("name: " + name);
    System.out.println("amount: " + outstanding);
  }
  ```

  ##### 为什么重构

  ```
   在一个方法里发现的行越多，就越难理解清楚这个方法是干什么的，这就是重构的最主要原因。
   除了消除你的代码粗边界外，提取方法也是是许多重构手段，去处理的第一步
  ```

  ##### 好处

  ```
      更加可读的代码！保证看到这个方法的名字就知道你这个方法的目的，形如：creatOrder()等。
      越少的代码重复；通常在一个方法里发现一些代码能被用在你程序里其他地方，
      因此你可以替换掉重复的代码片段，在这个位置去调用你准备抽象出来新的方法。
      隔离出独立的代码部分，意味着出现错误的可能性更小，例如错误的变量被修改了。
  ```

  ##### 怎么样重构

  ```
     1、 知其名而晓其意:
      新建一个新的方法并且给它取一个这样的名字,看到这个方法名字，这个方法的目的就不言而喻呢。 
     2、复制相关的代码片段到你的新方法里，删除旧的地方的代码片段，取而代之用新的方法调用替换。
     找到代码片段里的所有被使用的变量，它们仅仅声明在代码片段里，没有在外部被使用，简单点做法是移到新方法里，它们会变成这
  个新方法的内部变量。
     3、如果这个变量声明在你要提取的方法之前。你需要把这个变量作为参数传递给你的新方法，为了使用先前就包含在里面的值。通过使用
   Replace Temp with Query，有时候很轻松的就可以摆脱这些变量。
  ```

  **2、Large Method**

   **症状**

  ```
  一个类包含了太多的代码块/方法/代码行
  ```

  **问题原因**

  ```
  类通常一开始很小。但是随着时间积累和程序的增长会越来越膨胀
  臃肿。
  长的方法通常也是这样，程序员通常会觉得在一个存在的类里写一个新
  特性比新建一个类再新写一个特性容易
  ```

  **治疗**

  ```
  当一个类穿戴了太多的功能性帽子，考虑一下把他们分开。
  Extract Class 帮助那些巨大的类某些行为能被剥离出来形成单独的
  组件。
  Extract Subclass帮助那些巨大的类某些行为能被用于不同的方式
  实现或者很少使用。
  Extract Interface帮助那些有必要有一个操作和行为清单，这客户
  端能使用的。
  如果一个巨大的类负责图形界面，你最好试着移动它的数据和行为到一
  个单独的领域对象，这样做的话，有必要存储数据在2个地方，并且
  保持数据的一致性。 Duplicate Observed Data提供了一种处理
  方式。
  ```

  ##### Payoff

  ```
  重构这些类避免开发者花大量时间时间去理解大量的关于这个类的属
  性。
  在许多情况下，拆分大的类到多个部分可以避免代码和功能重复。
  ```

  ##### 3、Primitive Obsession

  ##### 体征

  ```
  在简单的小任务里使用原语替换小对象（例如货币、范围、特殊的小字
  符如电话号码等）
  编码信息使用常量(比如：常量USER_ADMIN_ROLE = 1涉及到用户管
  理员权限的)
  在数据数组中使用字符串常量作为字段名
  ```

  

  ##### 问题原因

  

  ##### 治疗

  

  ##### 报酬

  

  ##### 3、Replace Temp with Query

  **problem**

      将表达式的结果放在本地变量中以便稍后再代码中使用


  ```java
  double calculateTotal() {
    double basePrice = quantity * itemPrice;
    if (basePrice > 1000) {
      return basePrice * 0.95;
    }
    else {
      return basePrice * 0.98;
    }
  }
  ```

  **Solution**

  ```
  移动整个表达式到一个单独的方法里，这个方法返回表达式的结果
  用查询方法的方式去替代这个变量，如果需要合并这个新的方法在
  其他方法里。
  ```

  ```java
  double calculateTotal() {
    if (basePrice() > 1000) {
      return basePrice() * 0.95;
    }
    else {
      return basePrice() * 0.98;
    }
  }
  double basePrice() {
    return quantity * itemPrice;
  }
  ```

  **为什么要重构**

  ```
  这种重构可以为上面的Extract Method打下基础。
  同样的表达式有时候也会被发现在其它方法中使用，这也是考虑新建
  一个通用的方法的原因。
  ```

  **好处**

  ```
  代码的可读性，如果一个方法叫做getTax()比orderPrice*0.2更加容易让人理解，知道这个方法的目的
  通过删除重复代码使代码瘦身。如果这个被替换的行被在多出方法使用
  ```

  **Good to Know**

  **性能**

  ```
  这种重构是不是会引起一个新的问题，是否会引起性能下降，最诚实的答案是：是的，
  这个结果代码会因为查询一个新方法而导致性能下降，
  但是相对于现在超快的cpu处理速度和卓越的编译器，这种负担几乎可以忽略不计，
  相比较而言，可读的代码和这个抽出的新方法可以用在程序的其他代码地方
  -谢谢这样的重构-有着非常明显的好处。
  尽管如此，如果你的临时变量被用来缓存耗时的表达式结果，你可能会停止重构直到提取这个表达式到一个新的方法里。
  ```

  **怎么样重构**

  ```
  1、确保一个变量在一个方法里被赋值一次仅仅一次，如果不是，那么
  使用Split Temporary Variable来确保你的变量将会被仅仅用来存储
  你的表达式的结果。
  2、使用提取方法的方法将你感兴趣的表达式放在一个新方法里，确保
  这个方法仅仅是返回一个值，并不改变这个对象的状态，如果这个方法
  影响对象的可见状态，使用Separate Query from Modifier
  3、对于你的新方法用查询去替换你的变量
  ```

  ##### 3、Inline Method

  

  

  ##### 4、Extract Variable

  

  ##### 5、Inline Temp

  

  ##### 6、Split Temporary Variable

  

  