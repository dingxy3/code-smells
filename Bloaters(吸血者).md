####                                                 Bloaters(吸血者)

```
    bloaters是一种代码、方法、类已经发展到了一个巨大的规模，以至很难工作。
    通常这种情况不会立马产生，是经过时间的积累项目的发展，尤其是开发者没有努力的想要去改变根除它。
```

* ##### Long Method

* ##### Large Class

* ##### Primitive Obsession

* ##### Long Parameter List

* ##### Data Clumps

  

**1、Long Method**

**症状：**

```
一个方法包含了太多行数的代码，通常某个方法已经超过了10行并且开始促使你问为什么呢
```

**问题原因：**

```
   就像加州旅馆一样，一些东西总是被添加进去但是却没有任何东西被删除掉。
   因为写代码总是比读代码容易。这种方法习惯和气味一直没有被注意到，直到它变成了一个丑陋的超大的野兽。
   心理上，通常新建一个新方法的难度超过了在先有方法上去添加改变，你会这样思想斗争着： 
   “它仅仅只需要在老方法改动的地方添加2行代码就可以实现功能，为了这2行代码创建一个新的方法是得不偿失的”     这就意味着另一行代码被添加进去，然后又是另一行代码，以此类推就产生了一团混乱的意大利面条代码。
```

**治疗：**

```
根据经验来说，如果你感觉到在一个方法内部需要增加一些注释，你就应该拿走这些代码把它放到一个新的方法里。
如果它需要解释的话，甚至一个单独的行应该被分割成一个新的单独的方法。
如果这个方法有一个清晰的名字，没有人为了知道这个方法干了什么会去查看这个代码内部的具体实现。
减少一个方法体的长度，使用 提取方法  
```

[Extract Method.md](./Extract Method.md)

##### 为什么重构

```
 在一个方法里发现的行越多，就越难理解清楚这个方法是干什么的，这就是重构的最主要原因。
 除了消除你的代码粗边界外，提取方法也是是许多重构手段，去处理的第一步
```

##### 好处

```
    更加可读的代码！保证看到这个方法的名字就知道你这个方法的目的，形如：creatOrder()等。
    越少的代码重复；通常在一个方法里发现一些代码能被用在你程序里其他地方，
    因此你可以替换掉重复的代码片段，在这个位置去调用你准备抽象出来新的方法。
    隔离出独立的代码部分，意味着出现错误的可能性更小，例如错误的变量被修改了。
```

##### 怎么样重构

```
   1、 知其名而晓其意:
    新建一个新的方法并且给它取一个这样的名字,看到这个方法名字，这个方法的目的就不言而喻呢。 
   2、复制相关的代码片段到你的新方法里，删除旧的地方的代码片段，取而代之用新的方法调用替换。
   找到代码片段里的所有被使用的变量，它们仅仅声明在代码片段里，没有在外部被使用，简单点做法是移到新方法里，它们会变成这
个新方法的内部变量。
   3、如果这个变量声明在你要提取的方法之前。你需要把这个变量作为参数传递给你的新方法，为了使用先前就包含在里面的值。通过使用
```

[Replace Temp with Query](./Replace-Temp-with-Query.md)```有时候很轻松的就可以摆脱这些变量。```

**2、Large Method**

 **症状**

```
一个类包含了太多的代码块/方法/代码行
```

**问题原因**

```
类通常一开始很小。但是随着时间积累和程序的增长会越来越膨胀
臃肿。
长的方法通常也是这样，程序员通常会觉得在一个存在的类里写一个新
特性比新建一个类再新写一个特性容易
```

**治疗**

```
当一个类穿戴了太多的功能性帽子，考虑一下把他们分开。
Extract Class 帮助那些巨大的类某些行为能被剥离出来形成单独的
组件。
Extract Subclass帮助那些巨大的类某些行为能被用于不同的方式
实现或者很少使用。
Extract Interface帮助那些有必要有一个操作和行为清单，这客户
端能使用的。
如果一个巨大的类负责图形界面，你最好试着移动它的数据和行为到一
个单独的领域对象，这样做的话，有必要存储数据在2个地方，并且
保持数据的一致性。 Duplicate Observed Data提供了一种处理
方式。
```

##### Payoff

```
重构这些类避免开发者花大量时间时间去理解大量的关于这个类的属
性。
在许多情况下，拆分大的类到多个部分可以避免代码和功能重复。
```

##### 3、Primitive Obsession

##### 体征

```
在简单的小任务里使用原语替换小对象（例如货币、范围、特殊的小字
符如电话号码等）
编码信息使用常量(比如：常量USER_ADMIN_ROLE = 1涉及到用户管
理员权限的)
在数据数组中使用字符串常量作为字段名
```



##### 问题原因

```
像其他的异味一样，primitive obsessions在产生时也很弱小，
程序员说"仅仅是存储数据的的一个字段"，加一个私有字段比新建一
整个类更加容易，不是吗？ 事情就这样办了，然后另一个字段也需要了
被以相同的方式加进来了。你瞧，这个类变得巨大和笨拙的

基本类型通常被用来模拟类型，因此你没有使用单独的数据类型
而是使用一串数字或者字符串来组成允许值列表给一些实体
通过常量给这些特殊的数字和字符串一个容易理解的名字，这就是
为什么他们传播的如此广泛如此久远

另一个使用不当的例子是字段模仿，这个类包含了各种各样的数据和
字符串常量（这些在这个类里都是被指定的）被用来作为数组索引
去获取数据。
```



##### 治疗

```
如果你有一个巨大的各种各样的私有字段，你可能需要把那些符合相同
的一组数据封装到他们自己的类里，更好的做法是，把与这些数据相关联
的行为习惯也移动到这个类里，对于这个任务，Replace Data Value 
with Object.

如果这个私有的字段的值被用在方法的参数里，使用 Introduce 
Parameter Object 或者 Preserve Whole Object

当复杂的数据被用作变量编码的时候，使用Replace Type Code with
Class, Replace Type Code with Subclasses 或者 Replace Type 
Code with State/Strategy
如果变量中有数组，使用Replace Array with Object.
```



##### 报酬

```
使用对象而不是私有属性，使得代码更加灵活

更加容易理解和组织的代码。对特定数据的操作在同一个地方
而不是散乱的。不用再去猜测这些奇怪的常量，为什么他们在数组

更加容易发现重复的代码
```



##### Long Parameter List

**症状**

```
一个方法超过了3个或者4个参数
```

**问题原因**

```
一个长的参数列表可能发生在把几个独特的算法合并到一个单一
的方法里。一个长的参数列表可能被创造用来控制运行哪些算法
以及怎么样运行。

长的参数列表使类更加相互独立产生的副产品。例如，创建独立对象
的代码需要这样一个方法从一个方法移动代码去调用另一个方法，但是
这个创建的对象需要当参数传递给这个方法，因此这原始的代码不知道
对象间的关系，以及依赖减少了。但是这些各自的对象被新建了，但是
他们每一个都需要各自的参数，这就意味着很长的参数。

很难理解如此长的参数列表。当这些参数越来越长，变得越来越对立
和难以理解使用。相较于一个长的参数列表，一个方法可以使用它们
自己的对象数据。如果当前对象不包含所有必要的数据,另一个对象
（包含所有数据的对象）可以被用来当做参数传递。
```

**治疗**

```
检查传递给参数的值，如果一些参数仅仅是另一些对象调用的结果，
使用Replace Parameter with Method Call，这个对象可以被
放在他自己类的字段里或者作为一个方法参数传递。

将这个对象本身作为参数传递，而不是从另一个对象接收到的数据作为
参数传递，通过使用 Preserve Whole Object.

如果存在各种各样的没有联系的数据对象，有时候你可以把它们
混合在一个参数对象来传递通过 Introduce Parameter Object.
```

**Payoff**

```
更加可读，更加短的代码。
重构揭露了以前没有注意到的重复的代码。
```

**When to Ignore**

```
别删除这样的参数，哪些呢？那些删除后会引起类之间不必要的依赖关系
```



##### 4、Data Clumps

**体征**

```
有时候不同部分的代码包含完全相同的变量组（比如一些连接数据库的）
参数），这些数据块需要被转移到他们自己的类里。

```

**问题原因**

```
这些错误的数据组都是因为糟糕的程序结构或者“copypasta 
programming”。
如果你想确定一些数据是否是数据块，仅仅删除一些数据的值来看看
其他的值是否还有意义。如果没有意义，这是一个好的信号，这组变量
应该被组合成一个新的对象。
```

**治疗**

```
如果重复的数据包含一个类的字段，使用 Extract Class移动这些字段
到它们自己的类里。
如果在方法的参数里传递了相同的数据块，使用 Introduce Parameter
Object 把它们设置为一个类
如果一些数据被传递给其它的方法，试着传递整个实体类对象给这个方法
而不是单独的字段。 Preserve Whole Object可以解决这问题

看看这些正在被使用的字段的代码，移动这些代码到一个对象类里，可能是
一个好主意
```

**Payoff**

```
提高了代码的组织性和更于理解，对特定数据的操作被移动到了一个单独
的地方，而不是随意的贯穿整个代码

减少代码长度
```

**When to Ignore**

```
作为方法入参传递一个实体类对象，而不是仅仅传递一个值（私有类型）
能在2个类之间创造一个不需要的依赖关系
```



##### 3、Replace Temp with Query

**problem**

```
将表达式的结果放在本地变量中以便稍后再代码中使用
```


  ```java
  double calculateTotal() {
    double basePrice = quantity * itemPrice;
    if (basePrice > 1000) {
      return basePrice * 0.95;
    }
    else {
      return basePrice * 0.98;
    }
  }
  ```

  **Solution**

  ```
  移动整个表达式到一个单独的方法里，这个方法返回表达式的结果
  用查询方法的方式去替代这个变量，如果需要合并这个新的方法在
  其他方法里。
  ```

  ```java
  double calculateTotal() {
    if (basePrice() > 1000) {
      return basePrice() * 0.95;
    }
    else {
      return basePrice() * 0.98;
    }
  }
  double basePrice() {
    return quantity * itemPrice;
  }
  ```

  **为什么要重构**

  ```
  这种重构可以为上面的Extract Method打下基础。
  同样的表达式有时候也会被发现在其它方法中使用，这也是考虑新建
  一个通用的方法的原因。
  ```

  **好处**

  ```
  代码的可读性，如果一个方法叫做getTax()比orderPrice*0.2更加容易让人理解，知道这个方法的目的
  通过删除重复代码使代码瘦身。如果这个被替换的行被在多出方法使用
  ```

  **Good to Know**

  **性能**

  ```
  这种重构是不是会引起一个新的问题，是否会引起性能下降，最诚实的答案是：是的，
  这个结果代码会因为查询一个新方法而导致性能下降，
  但是相对于现在超快的cpu处理速度和卓越的编译器，这种负担几乎可以忽略不计，
  相比较而言，可读的代码和这个抽出的新方法可以用在程序的其他代码地方
  -谢谢这样的重构-有着非常明显的好处。
  尽管如此，如果你的临时变量被用来缓存耗时的表达式结果，你可能会停止重构直到提取这个表达式到一个新的方法里。
  ```

  **怎么样重构**

  ```
  1、确保一个变量在一个方法里被赋值一次仅仅一次，如果不是，那么
  使用Split Temporary Variable来确保你的变量将会被仅仅用来存储
  你的表达式的结果。
  2、使用提取方法的方法将你感兴趣的表达式放在一个新方法里，确保
  这个方法仅仅是返回一个值，并不改变这个对象的状态，如果这个方法
  影响对象的可见状态，使用Separate Query from Modifier
  3、对于你的新方法用查询去替换你的变量
  ```

  ##### 3、Inline Method

  

  

  ##### 4、Extract Variable

  

  ##### 5、Inline Temp

  

  ##### 6、Split Temporary Variable

  

  